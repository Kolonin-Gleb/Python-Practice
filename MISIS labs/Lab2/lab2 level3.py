# Лабораторная 2. Задания 3его уравня.
# Для работы с Вложенными циклами!

# Мой номер в журнале = 8
# 8 < 9, поэтому решаю 8 задачу.

# Написать программу на Python.
# Вычислить сумму s, прекращая суммирование, когда очередной член суммы по
# абсолютной величине станет меньше 0,0001, при изменении аргумента x в указанном
# диапазоне [а, b] c шагом h. Для сравнения в каждой точке вычислить также функцию y =
# f(x), являющуюся аналитическим выражением ряда.

# Указание. Дано лишь к задаче 2.
'''
'''

import math

# Границы диапазона суммирования
a = 0.1
b = 1
h = 0.05 # Шаг
epsilon = 0.0001 # Точность

# Функция для вычисления факториала числа
def factorial(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# Функция для вычисления суммы ряда
def calculate_series(x):
    s = 0 # Общая сумма накопленная в границах диапозона
    part = 1 # первый член ряда
    i = 0

    # Сравнение члена по модулю с заданной точностью
    while abs(part) >= epsilon: # Чтобы не вычислять сумму для заданных параметров бесконечно.
        part = (2 * x) ** i / factorial(i)
        s += part
        i += 1
    
    return s

# Функция для вычисления суммы ряда
# С использованием рекурентного вычисления члена (Оптимизация)
def calculate_series_recurent(x):
    s = 0  # Общая сумма накопленная в границах диапозона
    part = 1  # Первый член ряда, т.к. (a0 = 1)
    i = 0  # Счетчик членов

    # Сравнение предыдущего члена по модулю с заданной точностью
    while abs(part) >= epsilon:  # Пока модуль текущего члена больше epsilon
        s += part  # Добавляем текущий член к общей сумме
        i += 1  # Увеличиваем счетчик членов
        part *= (2 * x) / i  # Рекуррентная формула для следующего члена

    return s

# Функция для вычисления e^(2x)
def calculate_y(x):
    return math.exp(2 * x)

# Проходим по диапазону [a, b] с шагом h
x = a # Устанавливаем начальную границу в x
while x <= b:
    # series_sum = calculate_series_recurent(x)
    series_sum = calculate_series_recurent(x)
    y_value = calculate_y(x)
    # :.4f - 4 знака после запятой. Такой точность вывода хватит, учитывая заданный epsilon
    print(f"x = {x:.2f} | s(x) = {series_sum:.4f} | y(x) = {y_value:.4f}")
    x += h

